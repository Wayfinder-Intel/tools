<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Facebook Meta Mapper</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Leaflet + MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Shared CSS -->
  <link rel="stylesheet" href="css/style.css">

  <style>
    /* Tool-specific overrides */
    :root {
      --logo-size: 72px;
    }

    html,
    body {
      overflow: hidden;
    }

    .container {
      flex: 1;
      min-height: 0;
      padding: 0 20px 20px;
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 20px;
      overflow: hidden;
      max-width: 100%;
      margin: 0;
    }

    .left-scroll {
      overflow: auto;
      padding-bottom: 12px;
    }

    .map-wrap {
      display: flex;
      flex-direction: column;
      min-height: 0;
      position: relative;
      padding: 0;
    }

    .map-body {
      flex: 1;
      min-height: 0;
      background: #151923;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    .graph-tip.leaflet-control {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .30);
    }

    .graph-tip .tip-close {
      appearance: none;
      border: none;
      background: transparent;
      color: inherit;
      font-size: 14px;
      line-height: 1;
      padding-left: 8px;
      cursor: pointer;
    }

    .tick {
      margin-left: 8px;
      font-weight: 700;
      color: #34d399;
    }

    .cross {
      margin-left: 6px;
      font-weight: 700;
      color: var(--danger);
    }

    .fix {
      margin-left: 8px;
      font-weight: 700;
      color: #fbbf24;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
    }

    .fix:focus {
      outline: 2px solid #3a4154;
      outline-offset: 2px;
    }

    .fb-link {
      display: inline-flex;
      width: 16px;
      height: 16px;
      margin-right: 8px;
      opacity: .95;
      align-items: center;
      justify-content: center;
    }

    .fb-link svg {
      width: 16px;
      height: 16px;
      fill: #3b82f6;
    }

    .fb-link:hover {
      opacity: 1;
    }

    .seed-dot {
      margin-left: 6px;
      font-size: 12px;
      line-height: 1;
      opacity: .95;
    }

    .toggle-wrap {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .list-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      margin: 6px 0;
      background: rgba(0, 0, 0, 0.2);
      transition: background 0.1s;
    }

    .list-row:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    @media (max-width: 1000px) {
      .container {
        grid-template-columns: 1fr;
        overflow: auto;
      }

      .map-wrap {
        min-height: 50vh;
      }
    }
  </style>

  <!-- Shared JS -->
  <script src="js/common.js" defer></script>
</head>

<body>
  <div class="page">
    <header>
      <div class="brand">
        <div class="brand-left">
          <a href="index.html">
            <img class="logo" src="Wayfinder.png" alt="Wayfinder Intelligence logo" />
          </a>
          <div>
            <h1 class="title">Facebook Meta Mapper</h1>
            <div class="help">Load JSON â†’ parse places â†’ cluster on the map. Export as JSON/CSV.</div>
          </div>
        </div>
      </div>
    </header>

    <div class="container">
      <!-- LEFT -->
      <div class="card left-card"
        style="display:flex; flex-direction:column; min-height:0; padding:0; overflow:hidden;">
        <div class="left-scroll" style="padding:20px;">
          <h2>Data & Options</h2>
          <div class="section" style="padding:0; margin-bottom:24px;">
            <input id="file" type="file" accept=".json" hidden />
            <div class="row">
              <label for="file" class="btn primary">Load JSON</label>
              <button id="btnClear" class="btn">Clear map</button>
            </div>
            <div class="row" style="margin-top:12px">
              <button id="btnExport" class="btn">Export JSON</button>
              <button id="btnExportCsv" class="btn">Export CSV</button>
            </div>

            <div class="row" style="margin-top:16px;">
              <label class="small" for="toggleAllMeta"
                style="display:flex; align-items:center; gap:6px; cursor:pointer;">
                <input id="toggleAllMeta" type="checkbox" checked> Try all meta lines
              </label>
            </div>

            <div class="row" style="margin-top:12px;">
              <select id="countryHint" title="Bias ambiguous results toward this country" style="width:100%">
                <option value="">Country: Auto</option>
                <option value="nz">New Zealand</option>
                <option value="au">Australia</option>
                <option value="fj">Fiji</option>
                <option value="ws">Samoa</option>
                <option value="to">Tonga</option>
                <option value="vu">Vanuatu</option>
                <option value="pg">Papua New Guinea</option>
                <option value="sb">Solomon Islands</option>
                <option value="gb">United Kingdom</option>
                <option value="us">United States</option>
                <option value="ca">Canada</option>
                <option value="il">Israel</option>
              </select>
            </div>
            <div class="row" style="margin-top:8px;">
              <input id="search" type="text" placeholder="Filter listâ€¦" style="width:100%" />
            </div>
            <div class="row" style="margin-top:8px;">
              <label class="toggle-wrap small" title="Hide rows & markers that arenâ€™t mapped" style="cursor:pointer;">
                <input id="onlyMapped" type="checkbox"> Show only mapped
              </label>
            </div>
          </div>

          <h2>People & Progress</h2>
          <div class="section" style="padding:0;">
            <div class="row small muted mb-2">Loaded entries appear below. Click to pan to marker.</div>
            <div class="row small muted mb-4">ðŸŒ± = Seed (no profile URL available)</div>

            <div id="list"
              style="max-height:300px; overflow:auto; border:1px solid var(--border); border-radius:10px; padding:6px; background:rgba(0,0,0,0.2);">
            </div>

            <div class="row" style="margin-top:12px; align-items:center;">
              <div class="small muted">Progress</div>
              <div
                style="flex:1; height:8px; border:1px solid var(--border); border-radius:999px; overflow:hidden; background:#0b0e14">
                <div id="bar"
                  style="height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#60a5fa); transition:width .2s ease;">
                </div>
              </div>
              <span id="pct" class="small">0%</span>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card map-wrap">
        <div class="map-body" id="map"></div>
      </div>
    </div>
  </div>

  <script>
    // ... (Keep existing JS logic) ...
    // I will include the full script logic here, adapted slightly for the new structure if needed.

    const $ = sel => document.querySelector(sel);
    const listEl = $('#list');
    const barEl = $('#bar');
    const pctEl = $('#pct');
    const fileEl = $('#file');
    const searchEl = $('#search');
    const tryAllEl = $('#toggleAllMeta');
    const countryHintEl = $('#countryHint');
    const onlyMappedEl = $('#onlyMapped');

    // Debounce helper
    function debounce(fn, delay = 250) {
      let t;
      return function (...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Map
    const map = L.map('map').setView([-41.2866, 174.7756], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap' }).addTo(map);

    // Yellow teardrop (Option E)
    function makeYellowIcon() {
      const svg =
        `<svg xmlns='http://www.w3.org/2000/svg' width='25' height='41' viewBox='0 0 25 41'>
         <defs>
           <filter id="sh" x="-50%" y="-50%" width="200%" height="200%">
             <feDropShadow dx="0" dy="1.3" stdDeviation="1.2" flood-color="rgba(0,0,0,0.35)"/>
           </filter>
         </defs>
         <path d='M12.5 0C5.6 0 0 5.6 0 12.5 0 21.9 12.5 41 12.5 41S25 21.9 25 12.5C25 5.6 19.4 0 12.5 0z'
               fill='#FACC15' filter='url(#sh)'/>
         <circle cx='12.5' cy='12.5' r='6.2' fill='none' stroke='white' stroke-width='1.2' opacity='.9'/>
         <circle cx='12.5' cy='12.5' r='5.0' fill='white' opacity='.9'/>
       </svg>`;
      return L.icon({
        iconUrl: 'data:image/svg+xml;base64,' + btoa(svg),
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        shadowSize: [41, 41], shadowAnchor: [12, 41]
      });
    }
    const areaIcon = makeYellowIcon();

    // Cluster
    const cluster = L.markerClusterGroup({
      maxClusterRadius: 60,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: false,
      spiderfyDistanceMultiplier: 1.4
    });
    map.addLayer(cluster);

    cluster.on('clusterclick', (e) => {
      const kids = e.layer.getAllChildMarkers();
      const same = kids.every(m => m.getLatLng().equals(kids[0].getLatLng()));
      if (same || map.getZoom() >= 13) e.layer.spiderfy();
      else e.layer.zoomToBounds();
    });

    // keep yellow during/after spiderfy
    function reapplyAreaIconFor(list) {
      (list || []).forEach(m => { if (m && m._kind === 'area' && m.setIcon) m.setIcon(areaIcon); });
    }
    cluster.on('spiderfied', e => reapplyAreaIconFor(e.markers));
    cluster.on('unspiderfied', e => reapplyAreaIconFor(e.markers));
    cluster.on('animationend', () => {
      const all = cluster.getLayers().filter(l => l && l._kind === 'area');
      reapplyAreaIconFor(all);
    });
    map.on('layeradd', e => {
      const m = e.layer;
      if (m && m._kind === 'area' && m.setIcon) m.setIcon(areaIcon);
    });

    // Bottom-left explanatory tip
    const TipControl = L.Control.extend({
      options: { position: 'bottomleft' },
      onAdd: function () {
        const div = L.DomUtil.create('div', 'graph-tip leaflet-control');
        div.innerHTML = `<span><b>Yellow</b> = approximate area (city/region). <b>Blue</b> = precise place.</span>
        <button class="tip-close" title="Dismiss">Ã—</button>`;
        L.DomEvent.disableClickPropagation(div);
        L.DomEvent.on(div.querySelector('.tip-close'), 'click', () => map.removeControl(tipControl));
        return div;
      }
    });
    const tipControl = new TipControl();
    map.addControl(tipControl);

    // ------- State -------
    let entries = [];
    let markers = [];
    let onMapPlaceClick = null, onKeyCancel = null;

    function setProgress(done, total) {
      const p = total ? Math.round((done / total) * 100) : 0;
      barEl.style.width = p + '%';
      pctEl.textContent = p + '%';
    }

    function clearMap() {
      cluster.clearLayers();
      markers.length = 0;
      cancelPlacement();
      for (const e of entries) {
        e._marker = null;
        if (e._tick) e._tick.textContent = '';
        if (e._cross) e._cross.textContent = '';
        if (e._fix) e._fix.style.display = 'none';
      }
      listEl.innerHTML = '';
      setProgress(0, 0);
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // cache
    const MEM = new Map();
    const CACHE_KEY = 'fbMetaGeoCacheV3';
    const CACHE_TTL_MS = 60 * 24 * 60 * 60 * 1000;
    (function loadCache() {
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return;
        const obj = JSON.parse(raw);
        for (const [k, v] of Object.entries(obj)) {
          if (v && v.t && (Date.now() - v.t) < CACHE_TTL_MS) MEM.set(k, v.v);
        }
      } catch { }
    })();
    function saveCache(q, v) {
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        const obj = raw ? JSON.parse(raw) : {};
        obj[q] = { v, t: Date.now() };
        localStorage.setItem(CACHE_KEY, JSON.stringify(obj));
      } catch { }
    }

    const countriesSet = new Set([
      'afghanistan', 'albania', 'algeria', 'andorra', 'angola', 'antigua and barbuda', 'argentina', 'armenia', 'australia', 'austria',
      'azerbaijan', 'bahamas', 'bahrain', 'bangladesh', 'barbados', 'belarus', 'belgium', 'belize', 'benin', 'bhutan', 'bolivia', 'bosnia and herzegovina',
      'botswana', 'brazil', 'brunei', 'bulgaria', 'burkina faso', 'burundi', 'cambodia', 'cameroon', 'canada', 'cape verde', 'central african republic',
      'chad', 'chile', 'china', 'colombia', 'comoros', 'congo', 'costa rica', 'cote dâ€™ivoire', 'ivory coast', 'croatia', 'cuba', 'cyprus', 'czech republic',
      'denmark', 'djibouti', 'dominica', 'dominican republic', 'ecuador', 'egypt', 'el salvador', 'equatorial guinea', 'eritrea', 'estonia', 'eswatini', 'ethiopia',
      'fiji', 'finland', 'france', 'gabon', 'gambia', 'georgia', 'germany', 'greece', 'grenada', 'guatemala', 'guinea', 'guinea-bissau', 'guyana',
      'haiti', 'honduras', 'hungary', 'iceland', 'india', 'indonesia', 'iran', 'iraq', 'ireland', 'israel', 'italy', 'jamaica', 'japan', 'jordan', 'kazakhstan',
      'kenya', 'kiribati', 'kuwait', 'kyrgyzstan', 'laos', 'latvia', 'lebanon', 'lesotho', 'liberia', 'libya', 'liechtenstein', 'lithuania', 'luxembourg',
      'madagascar', 'malawi', 'malaysia', 'maldives', 'mali', 'malta', 'marshall islands', 'mauritania', 'mauritius', 'mexico', 'micronesia', 'moldova',
      'monaco', 'mongolia', 'montenegro', 'morocco', 'mozambique', 'myanmar', 'namibia', 'nauru', 'nepal', 'netherlands', 'new zealand', 'nicaragua', 'niger',
      'nigeria', 'north macedonia', 'norway', 'oman', 'pakistan', 'palau', 'panama', 'papua new guinea', 'paraguay', 'peru', 'philippines', 'poland', 'portugal',
      'qatar', 'romania', 'russia', 'rwanda', 'saint kitts and nevis', 'saint lucia', 'saint vincent and the grenadines', 'samoa', 'san marino', 'sao tome and principe',
      'saudi arabia', 'senegal', 'serbia', 'seychelles', 'sierra leone', 'singapore', 'slovakia', 'slovenia', 'solomon islands', 'somalia', 'south africa', 'south korea',
      'spain', 'sri lanka', 'sudan', 'suriname', 'sweden', 'switzerland', 'syria', 'taiwan', 'tajikistan', 'tanzania', 'thailand', 'timor-leste', 'togo', 'tonga',
      'trinidad and tobago', 'tunisia', 'turkey', 'turkmenistan', 'tuvalu', 'uganda', 'ukraine', 'united arab emirates', 'united kingdom', 'great britain',
      'england', 'scotland', 'wales', 'northern ireland', 'united states', 'usa', 'uruguay', 'uzbekistan', 'vanuatu', 'venezuela', 'vietnam', 'yemen', 'zambia', 'zimbabwe'
    ]);

    function normalizeQuery(q) {
      return String(q || '')
        .replace(/\bCenrtal\b/ig, 'Central')
        .replace(/\bCity\b\s*$/i, '')
        .replace(/\s*,\s*/g, ', ')
        .replace(/[.\s]+$/, '')
        .replace(/^\s+|\s+$/g, '')
        .replace(/\s{2,}/g, ' ');
    }

    const POI_WORDS = /\b(University|College|School|High School|Polytechnic|Institute|Campus|Church|Cathedral|Temple|Mosque|Hospital|Clinic|Center|Centre|Theatre|Theater|Museum|Library|Hotel|Restaurant|Cafe|Airport|Station|Mall|St(reet)?|Rd|Road|Ave|Avenue|Hwy|Highway|NH-?\d+|No\.?\s*\d+)\b/i;
    const AREA_HINTS = /\b(country|state|region|province|county|district|city|town|village|hamlet|suburb|quarter|neighbou?rhood|island)\b/i;

    function looksPoiQuery(q) { return POI_WORDS.test(q); }
    function looksAreaQuery(q) {
      if (looksPoiQuery(q)) return false;
      const parts = q.split(',').map(s => s.trim()).filter(Boolean);
      return parts.length >= 2 || AREA_HINTS.test(q);
    }

    function classifyFromHit(hit) {
      const cls = (hit.class || '').toLowerCase();
      const typ = (hit.type || '').toLowerCase();
      const addr = (hit.addresstype || '').toLowerCase();
      const areaSet = /^(country|state|region|province|county|district|state_district|city|city_district|borough|municipality|local_authority|locality|subdivision|town|village|hamlet|suburb|quarter|neighbou?rhood|island)$/;
      if (cls === 'boundary') return 'area';
      if (cls === 'place' && areaSet.test(typ)) return 'area';
      if (areaSet.test(addr)) return 'area';
      const a = hit.address || {};
      if (a.city || a.town || a.village || a.municipality || a.locality) return 'area';
      return 'poi';
    }

    function classifyHit(hit, originalQuery) {
      const fromHit = classifyFromHit(hit);
      if (fromHit === 'poi' && looksAreaQuery(originalQuery)) return 'area';
      if (fromHit === 'area' && looksPoiQuery(originalQuery)) return 'poi';
      return fromHit;
    }

    function partsAndCountryGuess(q) {
      const parts = q.split(',').map(s => s.trim()).filter(Boolean);
      const last = (parts[parts.length - 1] || '').toLowerCase();
      return { parts, lastLooksCountry: countriesSet.has(last) };
    }

    const JOKE_PLACE_PATTERNS = [
      /university\s+of\s+life/i,
      /\bschool\s+of\s+hard\s+knocks\b/i,
      /\buniversity\s+of\s+hard\s+knocks\b/i,
      /\bthe?\s*school\s+of\s+life\b/i
    ];
    function isJokePlace(place) {
      return JOKE_PLACE_PATTERNS.some(rx => rx.test(place || ''));
    }

    // ---- Seed detection ----
    function isSeedLike(obj) {
      if (!obj) return false;
      if (obj.seed === true || obj.type === 'seed') return true; // explicit
      const noMeta = !Array.isArray(obj.meta) || obj.meta.length === 0;
      const noUrl = !obj.url && !obj.profileUrl;
      return noMeta && noUrl;
    }

    // Manual placement
    function startPlacement(entry) {
      cancelPlacement();
      map.getContainer().style.cursor = 'crosshair';
      onMapPlaceClick = function (ev) {
        try { placeEntryAt(entry, ev.latlng); }
        finally { cancelPlacement(); } // ALWAYS exit placement mode
      };
      map.on('click', onMapPlaceClick);
      onKeyCancel = function (ev) { if (ev.key === 'Escape') cancelPlacement(); };
      window.addEventListener('keydown', onKeyCancel);
    }
    function cancelPlacement() {
      if (onMapPlaceClick) map.off('click', onMapPlaceClick);
      if (onKeyCancel) window.removeEventListener('keydown', onKeyCancel);
      map.getContainer().style.cursor = '';
      onMapPlaceClick = null; onKeyCancel = null;
    }
    function placeEntryAt(entry, latlng) {
      if (entry._marker) cluster.removeLayer(entry._marker);
      const m = L.marker([latlng.lat, latlng.lng]).bindPopup(
        `<strong>${entry.name || 'â€”'}</strong><br>${entry.place || ''}<br><span class="small">manual placement</span>`
      );
      m._kind = 'poi';
      cluster.addLayer(m);
      entry._marker = m;
      if (entry._tick) entry._tick.textContent = 'âœ“';
      if (entry._cross) entry._cross.textContent = '';
      if (entry._fix) { entry._fix.style.display = 'inline'; entry._fix.title = 'Correct location'; }
      m.openPopup();
      applyFilterToMap(); // respect current filter/toggle
      renderList();       // update âœ“/âœ— and ensure row visibility under "only mapped"
    }

    function computeFbUrl(e) {
      if (e.url) return e.url;
      const id = e.id || '';
      if (!id) return null;
      if (/^\d{5,}$/.test(id)) return 'https://www.facebook.com/profile.php?id=' + id;
      if (/^[A-Za-z0-9.\-]+$/.test(id)) return 'https://www.facebook.com/' + id;
      return null;
    }

    // ------ Filtering logic (text + "only mapped") ------
    function entryMatchesText(e, f) {
      if (!f) return true;
      const hay = `${e.name || ''} ${e.place || ''}`.toLowerCase();
      return hay.includes(f);
    }
    function visibleByCurrentFilters(e) {
      const f = (searchEl.value || '').toLowerCase().trim();
      if (!entryMatchesText(e, f)) return false;
      if (onlyMappedEl.checked && !e._marker) return false;
      return true;
    }

    function renderList() {
      listEl.innerHTML = '';
      for (const e of entries) {
        if (!visibleByCurrentFilters(e)) continue;

        const row = document.createElement('div');
        row.className = 'list-row';

        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.alignItems = 'center';

        const fbUrl = computeFbUrl(e);
        if (fbUrl) {
          const a = document.createElement('a');
          a.className = 'fb-link';
          a.href = fbUrl; a.target = '_blank'; a.rel = 'noopener noreferrer';
          a.title = 'Open Facebook profile';
          a.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M22 12a10 10 0 1 0-11.5 9.9v-7h-2.3v-2.9h2.3V9.5c0-2.3 1.4-3.6 3.5-3.6 1 0 2 .2 2 .2v2.2h-1.1c-1.1 0-1.5.7-1.5 1.4v1.8h2.6l-.4 2.9h-2.2v7A10 10 0 0 0 22 12z"></path></svg>';
          a.addEventListener('click', ev => ev.stopPropagation());
          left.appendChild(a);
        }

        const textWrap = document.createElement('div');
        const seedMark = e.seed ? '<span class="seed-dot" title="Seed (no profile URL available)">ðŸŒ±</span>' : '';
        textWrap.innerHTML = `<strong>${e.name || 'â€”'}${seedMark}</strong><div class="small muted">${e.place || ''}</div>`;
        left.appendChild(textWrap);

        const right = document.createElement('div');
        right.style.display = 'flex'; right.style.alignItems = 'center';
        const tick = document.createElement('span'); tick.className = 'tick';
        const cross = document.createElement('span'); cross.className = 'cross';
        const fix = document.createElement('button'); fix.className = 'fix'; fix.type = 'button'; fix.textContent = '?';

        // Always allow correction via "?"
        fix.style.display = 'inline';
        fix.addEventListener('click', (ev) => { ev.stopPropagation(); startPlacement(e); });

        // Set current status (âœ“ / âœ—)
        if (e._marker) {
          tick.textContent = 'âœ“';
          cross.textContent = '';
          fix.title = 'Correct location';
        } else {
          tick.textContent = '';
          cross.textContent = 'âœ—';
          fix.title = 'Place manually';
        }

        right.appendChild(tick);
        right.appendChild(cross);
        right.appendChild(fix);

        row.appendChild(left);
        row.appendChild(right);

        row.addEventListener('click', () => { if (e._marker && cluster.hasLayer(e._marker)) { map.panTo(e._marker.getLatLng()); e._marker.openPopup(); } });

        e._row = row; e._tick = tick; e._cross = cross; e._fix = fix;
        listEl.appendChild(row);
      }
    }

    // Show/hide markers on the map based on current filters
    function applyFilterToMap() {
      const visibleMarkers = [];
      for (const e of entries) {
        const m = e._marker;
        if (!m) continue;
        const match = visibleByCurrentFilters(e);
        const onMap = cluster.hasLayer(m);
        if (match && !onMap) { cluster.addLayer(m); visibleMarkers.push(m); }
        else if (match && onMap) { visibleMarkers.push(m); }
        else if (!match && onMap) { cluster.removeLayer(m); }
      }
      if (visibleMarkers.length) {
        try {
          const group = L.featureGroup(visibleMarkers);
          map.fitBounds(group.getBounds().pad(0.2));
        } catch { }
      }
    }

    async function plot(entriesIn) {
      cluster.clearLayers();
      markers.length = 0;
      cancelPlacement();
      for (const e of entriesIn) {
        e._marker = null;
        if (e._tick) e._tick.textContent = '';
        if (e._cross) e._cross.textContent = '';
        if (e._fix) { e._fix.style.display = 'inline'; e._fix.title = 'Place manually'; }
      }
      setProgress(0, entriesIn.length);

      let done = 0;

      for (const e of entriesIn) {
        const noMeta = !Array.isArray(e.meta) || e.meta.length === 0;
        const place = e.place || '';

        // default: show âœ— until we map
        if (e._cross) { e._cross.textContent = 'âœ—'; e._cross.title = 'Not mapped'; }
        if (noMeta && e._fix) { e._fix.style.display = 'inline'; e._fix.title = 'Place manually (No meta)'; }

        // nothing to geocode
        if (!place) {
          if (e._fix) { e._fix.style.display = 'inline'; e._fix.title = 'Place manually (No place text)'; }
          done++; setProgress(done, entriesIn.length);
          continue;
        }

        // ignore joke places for auto, but allow manual
        if (isJokePlace(place)) {
          if (e._fix) { e._fix.style.display = 'inline'; e._fix.title = 'Place manually (Ignored joke place)'; }
          done++; setProgress(done, entriesIn.length);
          continue;
        }

        // Try geocoding
        const { hit } = await geocodeSmart(place, countryHintEl.value || '');
        if (hit) {
          const kind = classifyHit(hit, place);
          const opts = (kind === 'area') ? { icon: areaIcon } : {};
          const m = L.marker([hit.lat, hit.lon], opts).bindPopup(
            `<strong>${e.name || 'â€”'}</strong><br>${place || ''}<br><span class="small">${hit.display}</span>`
          );
          m._kind = kind;
          cluster.addLayer(m);
          e._marker = m;
          markers.push(m);
          if (e._tick) e._tick.textContent = 'âœ“';
          if (e._cross) e._cross.textContent = '';
          if (e._fix) { e._fix.style.display = 'inline'; e._fix.title = 'Correct location'; }
        } else {
          if (e._fix) { e._fix.style.display = 'inline'; e._fix.title = `Place manually (Couldn't geocode)`; }
          if (e._cross) { e._cross.textContent = 'âœ—'; e._cross.title = `Not mapped`; }
        }

        done++; setProgress(done, entriesIn.length);
      }

      if (markers.length) {
        try { map.fitBounds(cluster.getBounds().pad(0.2)); } catch { }
      }

      applyFilterToMap(); // enforce current text + mapped filters
    }

    // Geocoder (Nominatim with polite delay + memo)
    async function geocodeSmart(qOriginal, userHintCode = '') {
      if (!qOriginal) return { hit: null, tried: [] };
      let q = normalizeQuery(qOriginal);
      const tried = [];
      const ccParamBase = userHintCode || '';

      const attempt = async (qq, ccParam = ccParamBase) => {
        const key = qq + '||' + ccParam;
        if (MEM.has(key)) return MEM.get(key);
        tried.push(qq + (ccParam ? ` [cc=${ccParam}]` : ''));
        await sleep(1100);
        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&addressdetails=1&q=${encodeURIComponent(qq)}${ccParam ? `&countrycodes=${ccParam}` : ''}`;
        try {
          const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
          const js = await res.json();
          const j0 = js && js[0];
          const hit = j0 ? {
            lat: +j0.lat, lon: +j0.lon, display: j0.display_name,
            class: j0.class, type: j0.type, addresstype: j0.addresstype, address: j0.address || null
          } : null;
          MEM.set(key, hit); saveCache(key, hit);
          return hit;
        } catch {
          MEM.set(key, null); saveCache(key, null);
          return null;
        }
      };

      let hit = await attempt(q);
      if (hit) return { hit, tried };

      const { parts, lastLooksCountry } = partsAndCountryGuess(q);

      if (parts.length >= 2 && !lastLooksCountry) {
        const lastOnly = parts[parts.length - 1];
        let probe = await attempt(lastOnly, '');
        const countryName = probe && probe.address && (probe.address.country || probe.address.country_name);
        if (countryName) {
          const qWithCountry = q + ', ' + countryName;
          hit = await attempt(qWithCountry);
          if (hit) return { hit, tried };
        }
      }

      if (parts.length >= 2) {
        const last2 = parts.slice(-2).join(', ');
        hit = await attempt(last2);
        if (hit) return { hit, tried };
      }

      if (/\b(University|College|School|High School|Polytechnic|Institute|Campus|Church|Hospital|Ministry|Department|Diocese|Grammar School)\b/i.test(q)) {
        const locOnly = parts.slice(1).join(', ').trim();
        if (locOnly) {
          hit = await attempt(locOnly);
          if (hit) return { hit, tried };
        }
      }

      if (parts.length >= 1) {
        const last1 = parts.slice(-1)[0];
        hit = await attempt(last1);
        if (hit) return { hit, tried };
      }

      return { hit: null, tried };
    }

    // ---------------- JSON LOADER (robust shapes) ----------------
    function findBestNodes(obj) {
      if (!obj || typeof obj !== 'object') return null;

      const preferredKeys = [
        'nodes', 'entities', 'people', 'items', 'results', 'profiles', 'records', 'list', 'rows'
      ];

      for (const key of preferredKeys) {
        if (Array.isArray(obj[key])) return obj[key];
      }
      if (obj.data) {
        for (const key of preferredKeys) {
          if (Array.isArray(obj.data[key])) return obj.data[key];
        }
        if (Array.isArray(obj.data)) return obj.data;
      }
      if (obj.graph) {
        for (const key of preferredKeys) {
          if (Array.isArray(obj.graph[key])) return obj.graph[key];
        }
        if (Array.isArray(obj.graph)) return obj.graph;
      }
      let best = null, bestScore = -1;

      function scoreArray(arr) {
        if (!Array.isArray(arr) || arr.length === 0) return -1;
        let hits = 0;
        for (const el of arr) {
          if (el && typeof el === 'object' && (el.name || el.id || el.title || el.meta || el.place || el.location)) hits++;
        }
        const ratio = hits / arr.length;
        return (arr.length >= 3 && ratio >= 0.3) ? (arr.length * ratio) : -1;
      }

      function walk(o, depth = 0) {
        if (!o || depth > 5) return;
        if (Array.isArray(o)) {
          const s = scoreArray(o);
          if (s > bestScore) { best = o; bestScore = s; }
          return;
        }
        if (typeof o === 'object') {
          for (const k in o) {
            if (!Object.prototype.hasOwnProperty.call(o, k)) continue;
            walk(o[k], depth + 1);
          }
        }
      }
      walk(obj);
      return best || null;
    }

    function extractPlaceFromMetas(metas) {
      if (!metas || metas.length === 0) return '';
      const lines = tryAllEl.checked ? metas : [metas[0]];

      for (const raw of lines) {
        if (!raw) continue;
        let t = String(raw).trim();

        const parts = t.split(/\bat\b/i);
        if (parts.length > 1) t = parts[parts.length - 1].trim().replace(/^the\s+/i, '');
        t = t.replace(/\b\d{4}\s*[-â€“]\s*\d{4}\b/g, '').replace(/\bsince\s+\d{4}\b/ig, '').trim();

        if (isJokePlace(t)) continue;

        if (/,/.test(t) || /\b(University|College|School|High School|Polytechnic|Institute|Campus|Diocese|Hospital|Church|Grammar School|City|District|Province)\b/i.test(t)) {
          return t;
        }
      }
      return '';
    }

    function normalizeArray(rawArr) {
      return rawArr.map(x => {
        const metas = (
          Array.isArray(x?.meta) ? x.meta :
            (typeof x?.meta === 'string' ? [x.meta] :
              Array.isArray(x?.meta_lines) ? x.meta_lines :
                Array.isArray(x?.metas) ? x.metas :
                  (typeof x?.metaLine === 'string' ? [x.metaLine] :
                    Array.isArray(x?.details) ? x.details :
                      Array.isArray(x?.info) ? x.info :
                        (typeof x?.details === 'string' ? [x.details] :
                          (typeof x?.info === 'string' ? [x.info] : [])))))
          .filter(Boolean);

        let place = x.place || x.location || x.city || x.hometown || '';
        if (!place) place = extractPlaceFromMetas(metas);

        const url = x.url || x.profileUrl || x.link || x.href || null;

        const item = {
          name: x.name || x.title || x.fullname || x.full_name || x.id || '',
          id: x.id || x.username || x.handle || '',
          url,
          place,
          meta: metas
        };
        item.seed = isSeedLike(item);
        return item;
      });
    }

    function normalizeFromUnknown(raw) {
      if (Array.isArray(raw)) return normalizeArray(raw);

      if (raw && typeof raw === 'object') {
        if (Array.isArray(raw.nodes)) return normalizeArray(raw.nodes);
        if (Array.isArray(raw.entities)) return normalizeArray(raw.entities);
        if (Array.isArray(raw.people)) return normalizeArray(raw.people);
        if (Array.isArray(raw.items)) return normalizeArray(raw.items);
        if (Array.isArray(raw.results)) return normalizeArray(raw.results);
        if (Array.isArray(raw.profiles)) return normalizeArray(raw.profiles);
        if (Array.isArray(raw.records)) return normalizeArray(raw.records);
        if (Array.isArray(raw.list)) return normalizeArray(raw.list);
        if (Array.isArray(raw.rows)) return normalizeArray(raw.rows);

        const best = findBestNodes(raw);
        if (best) return normalizeArray(best);
      }
      return [];
    }

    fileEl.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = ev => {
        try {
          const json = JSON.parse(ev.target.result);
          entries = normalizeFromUnknown(json);
          plot(entries);
          renderList();
        } catch (err) { alert('Invalid JSON: ' + err); }
      };
      r.readAsText(f);
      e.target.value = '';
    });

    document.getElementById('btnClear').addEventListener('click', clearMap);
    document.getElementById('btnExport').addEventListener('click', () => {
      if (!entries.length) return;
      const blob = new Blob([JSON.stringify(entries, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'mapped_data.json';
      a.click();
      URL.revokeObjectURL(url);
    });
    document.getElementById('btnExportCsv').addEventListener('click', () => {
      if (!entries.length) return;
      const rows = ['Name,ID,Place,Lat,Lon,URL'];
      for (const e of entries) {
        const lat = e._marker ? e._marker.getLatLng().lat : '';
        const lon = e._marker ? e._marker.getLatLng().lng : '';
        const row = [
          `"${(e.name || '').replace(/"/g, '""')}"`,
          `"${(e.id || '').replace(/"/g, '""')}"`,
          `"${(e.place || '').replace(/"/g, '""')}"`,
          lat, lon,
          `"${(e.url || '').replace(/"/g, '""')}"`
        ];
        rows.push(row.join(','));
      }
      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'mapped_data.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    searchEl.addEventListener('input', debounce(() => {
      applyFilterToMap();
      renderList();
    }, 300));

    onlyMappedEl.addEventListener('change', () => {
      applyFilterToMap();
      renderList();
    });

  </script>
</body>

</html>